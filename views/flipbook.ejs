      <!DOCTYPE html>
      <html lang="vi">
      <head>
        <meta charset="UTF-8" />
        <title><%= name %></title>
        <link rel="stylesheet" href="/public/style.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" defer></script>
        <style>
          /* Highlight overlay */
          #highlightOverlay {
            position:absolute;
            top:0; left:0;
            pointer-events:none;
          }
          .highlight-box {
            position: absolute;
            background: rgba(255, 224, 102, 0.2); /* gi·∫£m t·ª´ 0.35 xu·ªëng 0.2 */
            border-radius: 2px;
          }


          /* Marker overlay */
          #markerOverlay {
            position:absolute;
            top:0; left:0;
            pointer-events:none;
          }
          .chunk-marker {
            position:absolute;
            pointer-events:auto;
            z-index:20;
            color:red;
            font-size:14px;
            cursor:pointer;
            user-select:none;
          }

          .page-container { 
            position:relative; 
            display:inline-block; 
          }
          #chunkTimeline {
            display: flex;
            overflow-x: auto;
            margin: 0;            /* b·ªè margin ƒë·ªÉ s√°t m√©p */
            padding: 6px;
            width: 100vw;         /* full viewport width */
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 0;     /* b·ªè bo g√≥c n·∫øu mu·ªën gi·ªëng h·∫≥n */
            gap: 6px;
            background: #fafafa;
          }

          .chunk-block {
            flex: 0 0 auto;
            min-width: 32px;
            padding: 6px 10px;
            background: #eee;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ddd;
          }
          .chunk-block.active {
            background: #ffd966;
            border-color: #e6c441;
          }

        </style>
      </head>
      <body>

        <div id="loadingAlert" class="alert">
          üìÑ Vui l√≤ng ch·ªù gi√¢y l√°t ƒë·ªÉ t·∫£i t√†i li·ªáu...
        </div>

        <main>
          <div class="controls">
            <button class="btn" id="prevBtn">‚¨ÖÔ∏è Trang tr∆∞·ªõc</button>
            <button class="btn" id="nextBtn">‚û°Ô∏è Trang sau</button>
            <button class="btn primary" id="readBtn">üîä ƒê·ªçc trang</button>
            <button class="btn" id="pauseBtn">‚è∏ D·ª´ng</button>
            <button class="btn" id="resumeBtn">‚ñ∂Ô∏è Ti·∫øp t·ª•c</button>
            <span id="pageInfo" class="page-info"></span>
          </div>

          <div id="chunkTimeline"></div>


          <!-- Canvas + overlays -->
          <div class="page-container">
            <canvas id="pdfCanvas"></canvas>
            <div id="highlightOverlay"></div>
            <div id="markerOverlay"></div>
          </div>
        </main>

        <script>
        document.addEventListener('DOMContentLoaded', () => {
          const loadingAlert = document.getElementById('loadingAlert');
          setTimeout(() => loadingAlert.style.display = 'none', 3000);

          const pdfUrl = "<%= link %>";
          const canvas = document.getElementById('pdfCanvas');
          const ctx = canvas.getContext('2d');
          const prevBtn = document.getElementById('prevBtn');
          const nextBtn = document.getElementById('nextBtn');
          const readBtn = document.getElementById('readBtn');
          const pauseBtn = document.getElementById('pauseBtn');
          const resumeBtn = document.getElementById('resumeBtn');
          const pageInfo = document.getElementById('pageInfo');
          const highlightOverlay = document.getElementById('highlightOverlay');
          const markerOverlay    = document.getElementById('markerOverlay');

          const flipSound = new Audio("https://raw.githubusercontent.com/ninjavanxuantruong/xaydungdangxuangiang/main/flipcard-91468.mp3");
          flipSound.volume = 0.6;
          flipSound.load();

          let audioCtx = null;
          function unlockAudio() {
            flipSound.play().then(() => {
              flipSound.pause();
              flipSound.currentTime = 0;
            }).catch(()=>{});
            if (!audioCtx) {
              audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === "suspended") {
              audioCtx.resume();
            }
            document.removeEventListener("touchstart", unlockAudio);
            document.removeEventListener("click", unlockAudio);
          }
          document.addEventListener("touchstart", unlockAudio, { once: true });
          document.addEventListener("click", unlockAudio, { once: true });

          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

          let pdfDoc = null;
          let currentPage = 1;

          // Qu·∫£n l√Ω timeout highlight
          let activeTimeouts = [];
          let activeSources = []; // th√™m m·∫£ng n√†y

          function clearAllHighlightTimeouts() {
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts = [];
          }

          function stopAudio() {
            // D·ª´ng audio context
            if (audioCtx) {
              try { audioCtx.close(); } catch (e) { console.warn("AudioCtx close error:", e); }
              audioCtx = null;
            }

            // D·ª´ng t·∫•t c·∫£ source ƒëang ch·∫°y
            activeSources.forEach(src => {
              try { src.stop(); } catch(e) {}
            });
            activeSources = [];

            // Clear timeout highlight
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts = [];

            // Xo√° highlight c≈©
            highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
          }


          const loadingTask = pdfjsLib.getDocument({ url: pdfUrl });
          loadingTask.promise.then(doc => {
            pdfDoc = doc;
            renderPage(currentPage);
            updatePageInfo();
          }).catch(err => {
            console.error('PDF load error:', err);
            alert('Kh√¥ng th·ªÉ t·∫£i PDF. Vui l√≤ng ki·ªÉm tra link.');
          });

          function updatePageInfo() {
            if (!pdfDoc) return;
            pageInfo.textContent = `Trang ${currentPage} / ${pdfDoc.numPages}`;
          }

          function resyncOverlayScale() {
            const scaleX = canvas.clientWidth  / canvas.width;
            const scaleY = canvas.clientHeight / canvas.height;

            // Highlight c·∫ßn scale theo k√≠ch th∆∞·ªõc hi·ªÉn th·ªã
            highlightOverlay.style.transformOrigin = "top left";
            highlightOverlay.style.transform = `scale(${scaleX}, ${scaleY})`;

            // Marker KH√îNG scale (ƒë√£ d√πng to·∫° ƒë·ªô pixel th·∫≠t)
            markerOverlay.style.transform = "none";
          }



          async function renderPage(num) {
            const page = await pdfDoc.getPage(num);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            const dpr = window.devicePixelRatio || 1;

            canvas.width  = Math.floor(viewport.width  * dpr);
            canvas.height = Math.floor(viewport.height * dpr);

            const transform = dpr !== 1 ? [dpr, 0, 0, dpr, 0, 0] : null;
            const renderContext = { canvasContext: ctx, viewport, transform };
            await page.render(renderContext).promise;

            highlightOverlay.style.width  = canvas.width + "px";
            highlightOverlay.style.height = canvas.height + "px";
            markerOverlay.style.width     = canvas.width + "px";
            markerOverlay.style.height    = canvas.height + "px";

            resyncOverlayScale();
            highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
          }

          // (c√≤n ti·∫øp ph·∫ßn 2)
          // ====== H√†m l·∫•y text + highlight ======
          function getItemsWithBoxes(textContent, viewport) {
            const items = [];
            for (const item of textContent.items) {
              const text = (item.str || "").trim();
              if (!text) continue;
              const [vx, vy] = viewport.convertToViewportPoint(item.transform[4], item.transform[5]);
              const fontSize = Math.abs(item.transform[0] || item.height || 12);
              const height = fontSize;
              const width = item.width ? item.width * viewport.scale : text.length * fontSize * 0.5;
              items.push({ text, x: vx, y: vy - height, width, height });
            }
            return items;
          }


          // T√°ch d·∫•u c√¢u ra th√†nh item ri√™ng ƒë·ªÉ d·ªÖ nh·∫≠n di·ªán
          function normalizeItems(items) {
            const result = [];
            for (const it of items) {
              // T√°ch theo c√°c d·∫•u c√¢u ph·ªï bi·∫øn
              const parts = it.text.split(/([.,;:!?])/);
              for (const p of parts) {
                if (p.trim() !== "") {
                  result.push({ ...it, text: p });
                }
              }
            }
            return result;
          }


          function buildItemChunks(items, maxCharsPerChunk = 200) {
            const chunks = [];
            let startIdx = 0;

            const isPunctuationEnd = (text) => {
              const t = text.trim();
              return [".", ",", ";", ":", "!", "?"].includes(t) ||
                     [".", ",", ";", ":", "!", "?"].some(p => t.endsWith(p)) ||
                     t.includes("\n");
            };

            while (startIdx < items.length) {
              let accLen = 0;
              let endIdx = startIdx - 1;
              let lastPunctIdx = -1;

              for (let i = startIdx; i < items.length; i++) {
                const word = items[i].text;
                const addLen = word.length + (i > startIdx ? 1 : 0);

                if (accLen + addLen > maxCharsPerChunk) {
                  break;
                }

                accLen += addLen;
                endIdx = i;

                if (isPunctuationEnd(word)) {
                  lastPunctIdx = i;
                }
              }

              if (lastPunctIdx >= startIdx) {
                endIdx = lastPunctIdx;
              }

              if (endIdx < startIdx) {
                endIdx = startIdx;
              }

              // üëâ text cho highlight (gi·ªØ nguy√™n join c≈©)
              const textForHighlight = items.slice(startIdx, endIdx + 1)
                .map(it => it.text)
                .join(" ");

              // üëâ text cho TTS (join th√¥ng minh, kh√¥ng th√™m space tr∆∞·ªõc d·∫•u c√¢u)
              const textForTTS = items.slice(startIdx, endIdx + 1)
                .map(it => it.text)
                .reduce((acc, cur) => {
                  const t = cur.trim();
                  if ([ ".", ",", ";", ":", "!", "?" ].includes(t)) {
                    return acc + t;
                  } else {
                    return acc ? acc + " " + cur : cur;
                  }
                }, "");

              chunks.push({
                start: startIdx,
                end: endIdx,
                text: textForHighlight, // d√πng cho highlight
                tts: textForTTS         // d√πng cho TTS
              });

              // üëâ Log ƒë·ªÉ ki·ªÉm tra
              console.log(
                `Chunk ${chunks.length - 1}: length=${textForTTS.length}, lastChar="${textForTTS.slice(-1)}"`
              );

              startIdx = endIdx + 1;
            }

            return chunks;
          }





          function drawChunkOverlayByItems(chunk, items, overlay) {
            // Xo√° m·ªçi highlight c≈© ƒë·ªÉ lu√¥n ch·ªâ c√≤n 1 l·ªõp
            overlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            if (!chunk) return;

            // D√πng pixel th·∫≠t c·ªßa canvas ƒë·ªÉ kh·ªõp v·ªõi viewport ƒë√£ render
            const dpr = window.devicePixelRatio || 1;

            for (let i = chunk.start; i <= chunk.end; i++) {
              const it = items[i];
              if (!it) continue;

              const box = document.createElement("div");
              box.className = "highlight-box";

              // Nh√¢n v·ªõi dpr ƒë·ªÉ kh·ªõp v·ªã tr√≠ canvas
              box.style.left   = (it.x     * dpr) + "px";
              box.style.top    = (it.y     * dpr) + "px";
              box.style.width  = (it.width * dpr) + "px";
              box.style.height = (it.height* dpr) + "px";

              overlay.appendChild(box);
            }
          }


          // ====== Render timeline s·ªë ƒëo·∫°n (thay marker) ======
          function renderChunkTimeline(chunks, items) {
            const timeline = document.getElementById("chunkTimeline");
            timeline.innerHTML = "";

            chunks.forEach((chunk, i) => {
              const block = document.createElement("div");
              block.className = "chunk-block";
              block.textContent = i + 1; // ch·ªâ hi·ªán s·ªë th·ª© t·ª±

              block.addEventListener("click", () => {
                stopAudio();
                timeline.querySelectorAll(".chunk-block").forEach(el => el.classList.remove("active"));
                block.classList.add("active");
                playChunkFromIndex(i, chunks, items);
              });

              timeline.appendChild(block);
            });
          }

          function setActiveChunkBlock(index) {
            const blocks = document.querySelectorAll("#chunkTimeline .chunk-block");
            blocks.forEach(el => el.classList.remove("active"));
            if (blocks[index]) blocks[index].classList.add("active");
          }




          // ====== ƒê·ªçc to√†n b·ªô trang ======
          async function readCurrentPage() {
            if (!pdfDoc) return;
            stopAudio();

            const page = await pdfDoc.getPage(currentPage);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            const textContent = await page.getTextContent();

            let items = getItemsWithBoxes(textContent, viewport);
            if (!items.length) {
              alert('Trang n√†y kh√¥ng c√≥ vƒÉn b·∫£n (c√≥ th·ªÉ l√† ·∫£nh scan).');
              return;
            }

            // üëâ Chu·∫©n ho√° items: t√°ch d·∫•u c√¢u th√†nh item ri√™ng
            items = normalizeItems(items);

            // üëâ Chia chunk theo logic m·ªõi
            const chunks = buildItemChunks(items, 200);

            // üëâ Render highlight
            // üëâ Render timeline s·ªë ƒëo·∫°n
            renderChunkTimeline(chunks, items);


            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let stopRequested = false;
            let currentSource = null;
            let bufferQueue = [];

            async function fetchBuffer(snippet) {
              try {
                const url = `/tts?q=${encodeURIComponent(snippet)}`;
                console.log("üîä Fetching TTS for:", snippet); // log ƒë·ªÉ ki·ªÉm tra text g·ª≠i ƒëi
                const resp = await fetch(url);
                if (!resp.ok) {
                  throw new Error(`TTS request failed: ${resp.status}`);
                }
                const arrayBuffer = await resp.arrayBuffer();
                return await audioCtx.decodeAudioData(arrayBuffer);
              } catch (err) {
                console.error("‚ùå fetchBuffer error:", err);
                throw err;
              }
            }


            async function prefillQueue(startIndex, count = 3) {
              for (let j = 0; j < count && startIndex + j < chunks.length; j++) {
                bufferQueue.push(await fetchBuffer(chunks[startIndex + j].text));
              }
            }

            async function playOne(i) {
              if (stopRequested || i >= chunks.length) return;

              // n·∫øu queue tr·ªëng th√¨ fetch
              if (bufferQueue.length === 0) {
                bufferQueue.push(await fetchBuffer(chunks[i].text));
              }
              const buffer = bufferQueue.shift();

              const source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(audioCtx.destination);

              drawChunkOverlayByItems(chunks[i], items, highlightOverlay);
              setActiveChunkBlock(i);

              source.onended = () => {
                if (!stopRequested) {
                  // prefetch th√™m ƒë·ªÉ queue lu√¥n ƒë·∫ßy
                  if (i + 3 < chunks.length) {
                    fetchBuffer(chunks[i + 3].text).then(buf => bufferQueue.push(buf));
                  }
                  playOne(i + 1);
                }
              };

              source.start();
              currentSource = source;
            }

            // prefill queue tr∆∞·ªõc khi ph√°t
            await prefillQueue(0, 3);
            playOne(0);

            stopAudio = function() {
              stopRequested = true;
              bufferQueue = [];
              if (currentSource) {
                try { currentSource.stop(); } catch(e) {}
                currentSource = null;
              }
              if (audioCtx) {
                try { audioCtx.close(); } catch(e) {}
                audioCtx = null;
              }
              highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            }
          }





          // ====== Render marker ·ªü l·ªÅ ======
          function renderChunkMarkers(chunks, items) {
            markerOverlay.innerHTML = "";
            const dpr = window.devicePixelRatio || 1;

            const OFFSET_LEFT = -35;   // ƒë·∫©y ra ngo√†i l·ªÅ tr√°i
            const ICON_SIZE   = 28;    // k√≠ch th∆∞·ªõc v√πng ch·∫°m

            chunks.forEach((chunk, i) => {
              const firstIt = items[chunk.start];
              if (!firstIt) return;

              const marker = document.createElement("div");
              marker.className = "chunk-marker";
              marker.textContent = "‚ñ∂";

              // L·∫•y to·∫° ƒë·ªô item ƒë·∫ßu ti√™n
              const leftPx = (firstIt.x + OFFSET_LEFT) * dpr;
              const topPx  = (firstIt.y + firstIt.height / 2) * dpr;

              marker.style.left = leftPx + "px";
              marker.style.top  = (topPx - ICON_SIZE / 2) + "px";

              marker.style.width = ICON_SIZE + "px";
              marker.style.height = ICON_SIZE + "px";
              marker.style.lineHeight = ICON_SIZE + "px";
              marker.style.fontSize = "22px";

              marker.addEventListener("click", () => {
                playChunkFromIndex(i, chunks, items);
              });

              markerOverlay.appendChild(marker);
            });
          }




          // ====== ƒê·ªçc t·ª´ ƒëo·∫°n b·∫•t k·ª≥ ======
          async function playChunkFromIndex(startIndex, chunks, items) {
            stopAudio();

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let stopRequested = false;
            let currentSource = null;
            let bufferQueue = [];

            async function fetchBuffer(snippet) {
              const url = `/tts?q=${encodeURIComponent(snippet)}`;
              const resp = await fetch(url);
              const arrayBuffer = await resp.arrayBuffer();
              return await audioCtx.decodeAudioData(arrayBuffer);
            }

            async function prefillQueue(startIndex, count = 3) {
              for (let j = 0; j < count && startIndex + j < chunks.length; j++) {
                bufferQueue.push(await fetchBuffer(chunks[startIndex + j].text));
              }
            }

            async function playOne(i) {
              if (stopRequested || i >= chunks.length) return;

              if (bufferQueue.length === 0) {
                bufferQueue.push(await fetchBuffer(chunks[i].text));
              }
              const buffer = bufferQueue.shift();

              const source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(audioCtx.destination);

              drawChunkOverlayByItems(chunks[i], items, highlightOverlay);
              setActiveChunkBlock(i);

              source.onended = () => {
                if (!stopRequested) {
                  if (i + 3 < chunks.length) {
                    fetchBuffer(chunks[i + 3].text).then(buf => bufferQueue.push(buf));
                  }
                  playOne(i + 1);
                }
              };

              source.start();
              currentSource = source;
            }

            await prefillQueue(startIndex, 3);
            playOne(startIndex);

            stopAudio = function() {
              stopRequested = true;
              bufferQueue = [];
              if (currentSource) {
                try { currentSource.stop(); } catch(e) {}
                currentSource = null;
              }
              if (audioCtx) {
                try { audioCtx.close(); } catch(e) {}
                audioCtx = null;
              }
              highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            }
          }



            // ====== N√∫t ƒëi·ªÅu khi·ªÉn ======
            prevBtn.addEventListener('click', async () => {
              if (!pdfDoc || currentPage <= 1) return;
              currentPage--;
              stopAudio();
              document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
              await renderPage(currentPage);
              updatePageInfo();
              flipSound.currentTime = 0; flipSound.play();
            });

            nextBtn.addEventListener('click', async () => {
              if (!pdfDoc || currentPage >= pdfDoc.numPages) return;
              currentPage++;
              stopAudio();
              document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
              await renderPage(currentPage);
              updatePageInfo();
              flipSound.currentTime = 0; flipSound.play();
            });

            readBtn.addEventListener('click', () => {
              unlockAudio();
              readCurrentPage();
            });

            pauseBtn.addEventListener('click', () => {
              if (audioCtx && audioCtx.state === "running") audioCtx.suspend();
            });
            resumeBtn.addEventListener('click', () => {
              if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
            });

            // Swipe (mobile)
            let touchStartX = 0;
            canvas.addEventListener('touchstart', (e) => {
              touchStartX = e.changedTouches[0].screenX;
            });
            canvas.addEventListener('touchend', async (e) => {
              const touchEndX = e.changedTouches[0].screenX;
              const deltaX = touchEndX - touchStartX;
              if (Math.abs(deltaX) < 50) return;
              if (deltaX < 0 && currentPage < pdfDoc.numPages) {
                currentPage++;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              } else if (deltaX > 0 && currentPage > 1) {
                currentPage--;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              }
            });

            // Mouse drag (desktop)
            let startX = 0;
            canvas.addEventListener('mousedown', (e) => {
              startX = e.clientX;
            });
            canvas.addEventListener('mouseup', async (e) => {
              const endX = e.clientX;
              const deltaX = endX - startX;
              if (Math.abs(deltaX) < 80) return;
              if (deltaX < 0 && currentPage < pdfDoc.numPages) {
                currentPage++;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              } else if (deltaX > 0 && currentPage > 1) {
                currentPage--;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              }
            });

            // Khi xoay ngang/d·ªçc
            window.addEventListener('orientationchange', () => {
              if (!pdfDoc) return;
              renderPage(currentPage).then(() => {
                updatePageInfo();
                if (audioCtx && audioCtx.state === "running") {
                  resyncOverlayScale();
                }
              });
            });

            // Khi thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
            window.addEventListener('resize', () => {
              if (!pdfDoc) return;
              resyncOverlayScale();
            });

            }); // end DOMContentLoaded
            </script>
            </body>
            </html>
