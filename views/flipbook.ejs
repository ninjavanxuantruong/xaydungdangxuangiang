      <!DOCTYPE html>
      <html lang="vi">
      <head>
        <meta charset="UTF-8" />
        <title><%= name %></title>
        <link rel="stylesheet" href="/public/style.css" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" defer></script>
        <style>

          #controlBar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 999;
            background: #fff;
            padding: 8px 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
          }
          main {
            padding-top: 64px; /* ho·∫∑c ƒë√∫ng chi·ªÅu cao c·ªßa #controlBar */
          }



          /* Reset & global */
          html, body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;           /* tr√°nh tr√†n ngang */
            background: #fff;
          }

          body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
          }

          /* Main takes full width to allow proper centering of children */
          main {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 8px 12px;            /* ƒë·ªám nh·∫π ƒë·ªÉ kh√¥ng s√°t m√©p ·ªü mobile */
          }

          /* Core centering rule: every main block is centered via auto margins */
          .page-container,
          #chunkTimeline,
          #textView {
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
          }

          /* Desktop max-width: applied only when screen is wide enough */
          @media (min-width: 768px) {
            .page-container,
            #chunkTimeline,
            #textView {
              max-width: 960px;           /* ch·ªânh 860‚Äì1100 tu·ª≥ m·∫Øt; 960 l√† ti√™u chu·∫©n d·ªÖ ƒë·ªçc */
            }
          }

          /* Canvas container and responsive canvas */
          .page-container {
            position: relative;           /* anchor cho overlay */
          }

          #pdfCanvas {
            display: block;               /* lo·∫°i b·ªè inline kho·∫£ng tr·∫Øng */
            width: 100%;
            height: auto;                 /* gi·ªØ t·ªâ l·ªá */
          }

          /* Overlays aligned to canvas area */
          #highlightOverlay,
          #markerOverlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;         /* highlight kh√¥ng b·∫Øt s·ª± ki·ªán */
            width: 100%;
            height: 100%;
          }

          .highlight-box {
            position: absolute;
            background: rgba(255, 224, 102, 0.2);
            border-radius: 2px;
          }

          .chunk-marker {
            position: absolute;
            pointer-events: auto;         /* marker c√≥ th·ªÉ b·∫•m */
            z-index: 20;
            color: red;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
          }

          /* Timeline centered and constrained */
          #chunkTimeline {
            display: flex;
            gap: 6px;
            padding: 6px;
            border: 1px solid #ccc;
            background: #fafafa;
            border-radius: 0;
            overflow-x: auto;             /* cu·ªôn ngang khi nhi·ªÅu block */
          }

          .chunk-block {
            flex: 0 0 auto;
            min-width: 32px;
            padding: 6px 10px;
            background: #eee;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
            text-align: center;
            border: 1px solid #ddd;
          }
          .chunk-block.active {
            background: #ffd966;
            border-color: #e6c441;
          }

          /* Easy reading mode view: centered and readable */
          #textView {
            display: none;
            width: 100%;
            margin: 0 auto;
            min-height: 60vh;
            box-sizing: border-box;
            padding: 16px;
            line-height: 1.6;
            font-size: var(--readerFont, 18px);
            background: #fff;
            color: #222;
            overflow-y: auto;

            /* ‚úÖ Th√™m 2 d√≤ng n√†y */
            text-align: justify;
            hyphens: auto;
          }


          /* Highlight active chunk inside textView */
          .chunk-span.active {
            background: rgba(255, 224, 102, 0.6);
            border-radius: 2px;
          }

          /* Hide canvas/overlays when reader mode is active */
          .reader-active #pdfCanvas,
          .reader-active #highlightOverlay,
          .reader-active #markerOverlay {
            display: none !important;
          }

          /* Optional: prevent the timeline from stretching too tall on mobile */
          #chunkTimeline {
            max-height: 56px;
            margin-top: 96px;
          }

          /* Optional: sticky timeline when scrolling long text in reader mode */
          @media (min-width: 768px) {
            #chunkTimeline {
              position: sticky;
              top: 0;
              z-index: 50;
            }
          }



        </style>
      </head>
      <body>

        <div id="loadingAlert" class="alert">
          üìÑ Vui l√≤ng ch·ªù gi√¢y l√°t ƒë·ªÉ t·∫£i t√†i li·ªáu...
        </div>

        <main>
          <div id="controlBar">
            <button class="btn" id="prevBtn">‚¨ÖÔ∏è Trang tr∆∞·ªõc</button>
            <button class="btn" id="nextBtn">‚û°Ô∏è Trang sau</button>
            <button class="btn primary" id="readBtn">üîä ƒê·ªçc trang</button>
            <button class="btn" id="pauseBtn">‚è∏ D·ª´ng</button>
            <button class="btn" id="resumeBtn">‚ñ∂Ô∏è Ti·∫øp t·ª•c</button>
            <span id="pageInfo" class="page-info"></span>
            <button class="btn" id="readerToggleBtn">üì∞ Ch·∫ø ƒë·ªô d·ªÖ ƒë·ªçc</button>
            <button class="btn" id="zoomOutTextBtn">A-</button>
            <button class="btn" id="zoomInTextBtn">A+</button>
          </div>

          <div id="chunkTimeline"></div>
        
          <div id="textView"></div>

   


          <!-- Canvas + overlays -->
          <div class="page-container">
            <canvas id="pdfCanvas"></canvas>
            <div id="highlightOverlay"></div>
            <div id="markerOverlay"></div>
          </div>

          
        </main>

        <script>
        document.addEventListener('DOMContentLoaded', () => {
          const loadingAlert = document.getElementById('loadingAlert');
          setTimeout(() => loadingAlert.style.display = 'none', 3000);

          const pdfUrl = "<%= link %>";
          const canvas = document.getElementById('pdfCanvas');
          const ctx = canvas.getContext('2d');
          const prevBtn = document.getElementById('prevBtn');
          const nextBtn = document.getElementById('nextBtn');
          const readBtn = document.getElementById('readBtn');
          const pauseBtn = document.getElementById('pauseBtn');
          const resumeBtn = document.getElementById('resumeBtn');
          const pageInfo = document.getElementById('pageInfo');
          const highlightOverlay = document.getElementById('highlightOverlay');
          const markerOverlay    = document.getElementById('markerOverlay');

          const flipSound = new Audio("https://raw.githubusercontent.com/ninjavanxuantruong/xaydungdangxuangiang/main/flipcard-91468.mp3");
          flipSound.volume = 0.6;
          flipSound.load();

          let audioCtx = null;
          function unlockAudio() {
            flipSound.play().then(() => {
              flipSound.pause();
              flipSound.currentTime = 0;
            }).catch(()=>{});
            if (!audioCtx) {
              audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === "suspended") {
              audioCtx.resume();
            }
            document.removeEventListener("touchstart", unlockAudio);
            document.removeEventListener("click", unlockAudio);
          }
          document.addEventListener("touchstart", unlockAudio, { once: true });
          document.addEventListener("click", unlockAudio, { once: true });

          pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

          let pdfDoc = null;
          let currentPage = 1;

          // Qu·∫£n l√Ω timeout highlight
          let activeTimeouts = [];
          let activeSources = []; // th√™m m·∫£ng n√†y

          function clearAllHighlightTimeouts() {
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts = [];
          }

          function stopAudio() {
            // D·ª´ng audio context
            if (audioCtx) {
              try { audioCtx.close(); } catch (e) { console.warn("AudioCtx close error:", e); }
              audioCtx = null;
            }

            // D·ª´ng t·∫•t c·∫£ source ƒëang ch·∫°y
            activeSources.forEach(src => {
              try { src.stop(); } catch(e) {}
            });
            activeSources = [];

            // Clear timeout highlight
            activeTimeouts.forEach(id => clearTimeout(id));
            activeTimeouts = [];

            // Xo√° highlight c≈©
            highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
          }


          const loadingTask = pdfjsLib.getDocument({ url: pdfUrl });
          loadingTask.promise.then(doc => {
            pdfDoc = doc;
            renderPage(currentPage);
            updatePageInfo();
          }).catch(err => {
            console.error('PDF load error:', err);
            alert('Kh√¥ng th·ªÉ t·∫£i PDF. Vui l√≤ng ki·ªÉm tra link.');
          });

          function updatePageInfo() {
            if (!pdfDoc) return;
            pageInfo.textContent = `Trang ${currentPage} / ${pdfDoc.numPages}`;
          }

          function resyncOverlayScale() {
            const scaleX = canvas.clientWidth  / canvas.width;
            const scaleY = canvas.clientHeight / canvas.height;

            // Highlight c·∫ßn scale theo k√≠ch th∆∞·ªõc hi·ªÉn th·ªã
            highlightOverlay.style.transformOrigin = "top left";
            highlightOverlay.style.transform = `scale(${scaleX}, ${scaleY})`;

            // Marker KH√îNG scale (ƒë√£ d√πng to·∫° ƒë·ªô pixel th·∫≠t)
            markerOverlay.style.transform = "none";
          }



          async function renderPage(num) {
            const page = await pdfDoc.getPage(num);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            const dpr = window.devicePixelRatio || 1;

            canvas.width  = Math.floor(viewport.width  * dpr);
            canvas.height = Math.floor(viewport.height * dpr);

            const transform = dpr !== 1 ? [dpr, 0, 0, dpr, 0, 0] : null;
            const renderContext = { canvasContext: ctx, viewport, transform };
            await page.render(renderContext).promise;

            highlightOverlay.style.width  = canvas.width + "px";
            highlightOverlay.style.height = canvas.height + "px";
            markerOverlay.style.width     = canvas.width + "px";
            markerOverlay.style.height    = canvas.height + "px";

            resyncOverlayScale();
            highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
          }

          // (c√≤n ti·∫øp ph·∫ßn 2)
          // ====== H√†m l·∫•y text + highlight ======
          function getItemsWithBoxes(textContent, viewport) {
            const items = [];
            for (const item of textContent.items) {
              const text = (item.str || "").trim();
              if (!text) continue;
              const [vx, vy] = viewport.convertToViewportPoint(item.transform[4], item.transform[5]);
              const fontSize = Math.abs(item.transform[0] || item.height || 12);
              const height = fontSize;
              const width = item.width ? item.width * viewport.scale : text.length * fontSize * 0.5;
              items.push({ text, x: vx, y: vy - height, width, height });
            }
            return items;
          }


          // T√°ch d·∫•u c√¢u ra th√†nh item ri√™ng ƒë·ªÉ d·ªÖ nh·∫≠n di·ªán
          function normalizeItems(items) {
            const result = [];
            for (const it of items) {
              // T√°ch theo c√°c d·∫•u c√¢u ph·ªï bi·∫øn
              const parts = it.text.split(/([.,;:!?])/);
              for (const p of parts) {
                if (p.trim() !== "") {
                  result.push({ ...it, text: p });
                }
              }
            }
            return result;
          }


          function buildItemChunks(items, maxCharsPerChunk = 200) {
            const chunks = [];
            let startIdx = 0;

            const isPunctuationEnd = (text) => {
              const t = text.trim();
              return [".", ",", ";", ":", "!", "?"].includes(t) ||
                     [".", ",", ";", ":", "!", "?"].some(p => t.endsWith(p)) ||
                     t.includes("\n");
            };

            while (startIdx < items.length) {
              let accLen = 0;
              let endIdx = startIdx - 1;
              let lastPunctIdx = -1;

              for (let i = startIdx; i < items.length; i++) {
                const word = items[i].text;
                const addLen = word.length + (i > startIdx ? 1 : 0);

                if (accLen + addLen > maxCharsPerChunk) {
                  break;
                }

                accLen += addLen;
                endIdx = i;

                if (isPunctuationEnd(word)) {
                  lastPunctIdx = i;
                }
              }

              if (lastPunctIdx >= startIdx) {
                endIdx = lastPunctIdx;
              }

              if (endIdx < startIdx) {
                endIdx = startIdx;
              }

              // üëâ text cho highlight (gi·ªØ nguy√™n join c≈©)
              const textForHighlight = items.slice(startIdx, endIdx + 1)
                .map(it => it.text)
                .join(" ");

              // üëâ text cho TTS (join th√¥ng minh, kh√¥ng th√™m space tr∆∞·ªõc d·∫•u c√¢u)
              const textForTTS = items.slice(startIdx, endIdx + 1)
                .map(it => it.text)
                .reduce((acc, cur) => {
                  const t = cur.trim();
                  if ([ ".", ",", ";", ":", "!", "?" ].includes(t)) {
                    return acc + t;
                  } else {
                    return acc ? acc + " " + cur : cur;
                  }
                }, "");

              chunks.push({
                start: startIdx,
                end: endIdx,
                text: textForHighlight, // d√πng cho highlight
                tts: textForTTS         // d√πng cho TTS
              });

              // üëâ Log ƒë·ªÉ ki·ªÉm tra
              console.log(
                `Chunk ${chunks.length - 1}: length=${textForTTS.length}, lastChar="${textForTTS.slice(-1)}"`
              );

              startIdx = endIdx + 1;
            }

            return chunks;
          }





          function drawChunkOverlayByItems(chunk, items, overlay) {
            // Xo√° m·ªçi highlight c≈© ƒë·ªÉ lu√¥n ch·ªâ c√≤n 1 l·ªõp
            overlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            if (!chunk) return;

            // D√πng pixel th·∫≠t c·ªßa canvas ƒë·ªÉ kh·ªõp v·ªõi viewport ƒë√£ render
            const dpr = window.devicePixelRatio || 1;

            for (let i = chunk.start; i <= chunk.end; i++) {
              const it = items[i];
              if (!it) continue;

              const box = document.createElement("div");
              box.className = "highlight-box";

              // Nh√¢n v·ªõi dpr ƒë·ªÉ kh·ªõp v·ªã tr√≠ canvas
              box.style.left   = (it.x     * dpr) + "px";
              box.style.top    = (it.y     * dpr) + "px";
              box.style.width  = (it.width * dpr) + "px";
              box.style.height = (it.height* dpr) + "px";

              overlay.appendChild(box);
            }
          }


          // ====== Render timeline s·ªë ƒëo·∫°n (thay marker) ======
          function renderChunkTimeline(chunks, items) {
            const timeline = document.getElementById("chunkTimeline");
            timeline.innerHTML = "";

            chunks.forEach((chunk, i) => {
              const block = document.createElement("div");
              block.className = "chunk-block";
              block.textContent = i + 1; // ch·ªâ hi·ªán s·ªë th·ª© t·ª±

              block.addEventListener("click", () => {
                stopAudio();
                timeline.querySelectorAll(".chunk-block").forEach(el => el.classList.remove("active"));
                block.classList.add("active");
                playChunkFromIndex(i, chunks, items);
              });

              timeline.appendChild(block);
            });
          }

          function setActiveChunkBlock(index) {
            const blocks = document.querySelectorAll("#chunkTimeline .chunk-block");
            blocks.forEach(el => el.classList.remove("active"));
            if (blocks[index]) blocks[index].classList.add("active");
          }

          // ====== Reader Mode ======
          async function showTextView(pageNum, chunks, items) {
            const textView = document.getElementById("textView");
            textView.innerHTML = "";

            chunks.forEach((chunk, i) => {
              const span = document.createElement("span");
              span.className = "chunk-span";
              span.dataset.idx = i;
              span.textContent = chunk.map(idx => items[idx].str).join(" ");
              textView.appendChild(span);
              textView.appendChild(document.createTextNode(" "));
            });

            textView.style.setProperty('--readerFont', readerFontPx + "px");
            textView.style.display = "block";
            document.body.classList.add("reader-active");
          }

          function setActiveChunkInTextView(i) {
            document.querySelectorAll(".chunk-span").forEach(el => el.classList.remove("active"));
            const el = document.querySelector(`.chunk-span[data-idx="${i}"]`);
            if (el) el.classList.add("active");
          }





          // ====== ƒê·ªçc to√†n b·ªô trang ======
          async function readCurrentPage() {
            if (!pdfDoc) return;
            stopAudio();

            const page = await pdfDoc.getPage(currentPage);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            const textContent = await page.getTextContent();

            let items = getItemsWithBoxes(textContent, viewport);
            if (!items.length) {
              alert('Trang n√†y kh√¥ng c√≥ vƒÉn b·∫£n (c√≥ th·ªÉ l√† ·∫£nh scan).');
              return;
            }

            // üëâ Chu·∫©n ho√° items: t√°ch d·∫•u c√¢u th√†nh item ri√™ng
            items = normalizeItems(items);

            // üëâ Chia chunk theo logic m·ªõi
            const chunks = buildItemChunks(items, 200);

            // üëâ Render highlight
            // üëâ Render timeline s·ªë ƒëo·∫°n
            renderChunkTimeline(chunks, items);


            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let stopRequested = false;
            let currentSource = null;
            let bufferQueue = [];

            async function fetchBuffer(snippet) {
              try {
                const url = `/tts?q=${encodeURIComponent(snippet)}`;
                console.log("üîä Fetching TTS for:", snippet); // log ƒë·ªÉ ki·ªÉm tra text g·ª≠i ƒëi
                const resp = await fetch(url);
                if (!resp.ok) {
                  throw new Error(`TTS request failed: ${resp.status}`);
                }
                const arrayBuffer = await resp.arrayBuffer();
                return await audioCtx.decodeAudioData(arrayBuffer);
              } catch (err) {
                console.error("‚ùå fetchBuffer error:", err);
                throw err;
              }
            }


            async function prefillQueue(startIndex, count = 3) {
              for (let j = 0; j < count && startIndex + j < chunks.length; j++) {
                bufferQueue.push(await fetchBuffer(chunks[startIndex + j].text));
              }
            }

            async function playOne(i) {
              if (stopRequested || i >= chunks.length) return;

              // n·∫øu queue tr·ªëng th√¨ fetch
              if (bufferQueue.length === 0) {
                bufferQueue.push(await fetchBuffer(chunks[i].text));
              }
              const buffer = bufferQueue.shift();

              const source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(audioCtx.destination);

              if (readerMode) {
                setActiveChunkInTextView(i);
              } else {
                drawChunkOverlayByItems(chunks[i], items, highlightOverlay);
                setActiveChunkBlock(i);
              }


              source.onended = () => {
                if (!stopRequested) {
                  // prefetch th√™m ƒë·ªÉ queue lu√¥n ƒë·∫ßy
                  if (i + 3 < chunks.length) {
                    fetchBuffer(chunks[i + 3].text).then(buf => bufferQueue.push(buf));
                  }
                  playOne(i + 1);
                }
              };

              source.start();
              currentSource = source;
            }

            // prefill queue tr∆∞·ªõc khi ph√°t
            await prefillQueue(0, 3);
            playOne(0);

            stopAudio = function() {
              stopRequested = true;
              bufferQueue = [];
              if (currentSource) {
                try { currentSource.stop(); } catch(e) {}
                currentSource = null;
              }
              if (audioCtx) {
                try { audioCtx.close(); } catch(e) {}
                audioCtx = null;
              }
              highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            }
          }





          // ====== Render marker ·ªü l·ªÅ ======
          function renderChunkMarkers(chunks, items) {
            markerOverlay.innerHTML = "";
            const dpr = window.devicePixelRatio || 1;

            const OFFSET_LEFT = -35;   // ƒë·∫©y ra ngo√†i l·ªÅ tr√°i
            const ICON_SIZE   = 28;    // k√≠ch th∆∞·ªõc v√πng ch·∫°m

            chunks.forEach((chunk, i) => {
              const firstIt = items[chunk.start];
              if (!firstIt) return;

              const marker = document.createElement("div");
              marker.className = "chunk-marker";
              marker.textContent = "‚ñ∂";

              // L·∫•y to·∫° ƒë·ªô item ƒë·∫ßu ti√™n
              const leftPx = (firstIt.x + OFFSET_LEFT) * dpr;
              const topPx  = (firstIt.y + firstIt.height / 2) * dpr;

              marker.style.left = leftPx + "px";
              marker.style.top  = (topPx - ICON_SIZE / 2) + "px";

              marker.style.width = ICON_SIZE + "px";
              marker.style.height = ICON_SIZE + "px";
              marker.style.lineHeight = ICON_SIZE + "px";
              marker.style.fontSize = "22px";

              marker.addEventListener("click", () => {
                playChunkFromIndex(i, chunks, items);
              });

              markerOverlay.appendChild(marker);
            });
          }




          // ====== ƒê·ªçc t·ª´ ƒëo·∫°n b·∫•t k·ª≥ ======
          async function playChunkFromIndex(startIndex, chunks, items) {
            stopAudio();

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let stopRequested = false;
            let currentSource = null;
            let bufferQueue = [];

            async function fetchBuffer(snippet) {
              const url = `/tts?q=${encodeURIComponent(snippet)}`;
              const resp = await fetch(url);
              const arrayBuffer = await resp.arrayBuffer();
              return await audioCtx.decodeAudioData(arrayBuffer);
            }

            async function prefillQueue(startIndex, count = 3) {
              for (let j = 0; j < count && startIndex + j < chunks.length; j++) {
                bufferQueue.push(await fetchBuffer(chunks[startIndex + j].text));
              }
            }

            async function playOne(i) {
              if (stopRequested || i >= chunks.length) return;

              if (bufferQueue.length === 0) {
                bufferQueue.push(await fetchBuffer(chunks[i].text));
              }
              const buffer = bufferQueue.shift();

              const source = audioCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(audioCtx.destination);

              if (readerMode) {
                setActiveChunkInTextView(i);
              } else {
                drawChunkOverlayByItems(chunks[i], items, highlightOverlay);
                setActiveChunkBlock(i);
              }


              source.onended = () => {
                if (!stopRequested) {
                  if (i + 3 < chunks.length) {
                    fetchBuffer(chunks[i + 3].text).then(buf => bufferQueue.push(buf));
                  }
                  playOne(i + 1);
                }
              };

              source.start();
              currentSource = source;
            }

            await prefillQueue(startIndex, 3);
            playOne(startIndex);

            stopAudio = function() {
              stopRequested = true;
              bufferQueue = [];
              if (currentSource) {
                try { currentSource.stop(); } catch(e) {}
                currentSource = null;
              }
              if (audioCtx) {
                try { audioCtx.close(); } catch(e) {}
                audioCtx = null;
              }
              highlightOverlay.querySelectorAll(".highlight-box").forEach(el => el.remove());
            }
          }



            // ====== N√∫t ƒëi·ªÅu khi·ªÉn ======
            prevBtn.addEventListener('click', async () => {
              if (!pdfDoc || currentPage <= 1) return;
              currentPage--;
              stopAudio();
              document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
              await renderPage(currentPage);
              updatePageInfo();
              flipSound.currentTime = 0; flipSound.play();
            });

            nextBtn.addEventListener('click', async () => {
              if (!pdfDoc || currentPage >= pdfDoc.numPages) return;
              currentPage++;
              stopAudio();
              document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
              await renderPage(currentPage);
              updatePageInfo();
              flipSound.currentTime = 0; flipSound.play();
            });

            readBtn.addEventListener('click', () => {
              unlockAudio();
              readCurrentPage();
            });

            pauseBtn.addEventListener('click', () => {
              if (audioCtx && audioCtx.state === "running") audioCtx.suspend();
            });
            resumeBtn.addEventListener('click', () => {
              if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
            });

            // Swipe (mobile)
            let touchStartX = 0;
            canvas.addEventListener('touchstart', (e) => {
              touchStartX = e.changedTouches[0].screenX;
            });
            canvas.addEventListener('touchend', async (e) => {
              const touchEndX = e.changedTouches[0].screenX;
              const deltaX = touchEndX - touchStartX;
              if (Math.abs(deltaX) < 50) return;
              if (deltaX < 0 && currentPage < pdfDoc.numPages) {
                currentPage++;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              } else if (deltaX > 0 && currentPage > 1) {
                currentPage--;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              }
            });

            // Mouse drag (desktop)
            let startX = 0;
            canvas.addEventListener('mousedown', (e) => {
              startX = e.clientX;
            });
            canvas.addEventListener('mouseup', async (e) => {
              const endX = e.clientX;
              const deltaX = endX - startX;
              if (Math.abs(deltaX) < 80) return;
              if (deltaX < 0 && currentPage < pdfDoc.numPages) {
                currentPage++;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              } else if (deltaX > 0 && currentPage > 1) {
                currentPage--;
                stopAudio();
                document.getElementById("chunkTimeline").innerHTML = ""; // xo√° timeline c≈©
                await renderPage(currentPage);
                updatePageInfo();
                flipSound.currentTime = 0; flipSound.play();
              }
            });

            // Khi xoay ngang/d·ªçc
            window.addEventListener('orientationchange', () => {
              if (!pdfDoc) return;
              renderPage(currentPage).then(() => {
                updatePageInfo();
                if (audioCtx && audioCtx.state === "running") {
                  resyncOverlayScale();
                }
              });
            });

// Khi thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï
window.addEventListener('resize', () => {
  if (!pdfDoc) return;
  resyncOverlayScale();
});

// ====== Easy Reading Mode ======
let readerMode = false;
let readerFontPx = 18;

          function groupItemsByLine(items, lineGap = 6) {
            const lines = [];
            let currentLine = [];
            let prevY = null;

            for (const it of items) {
              if (prevY !== null && Math.abs(it.y - prevY) > lineGap) {
                if (currentLine.length) lines.push(currentLine);
                currentLine = [];
              }
              currentLine.push(it);
              prevY = it.y;
            }
            if (currentLine.length) lines.push(currentLine);
            return lines;
          }

          async function showTextView(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            const textContent = await page.getTextContent();

            let items = getItemsWithBoxes(textContent, viewport);
            items = normalizeItems(items);
            const chunks = buildItemChunks(items, 200);

            const textView = document.getElementById("textView");
            textView.innerHTML = "";

            chunks.forEach((chunk, i) => {
              const span = document.createElement("span");
              span.className = "chunk-span";
              span.dataset.idx = i;
              span.textContent = chunk.tts; // d√πng text TTS ƒë√£ join
              textView.appendChild(span);
              textView.appendChild(document.createTextNode(" "));
            });

            textView.style.setProperty('--readerFont', readerFontPx + "px");
            textView.style.display = "block";
            document.body.classList.add("reader-active");

            // render timeline cho ch·∫ø ƒë·ªô d·ªÖ ƒë·ªçc
            renderChunkTimeline(chunks, items);

            // l∆∞u l·∫°i ƒë·ªÉ playChunkFromIndex d√πng
            window.lastChunks = chunks;
            window.lastItems = items;
          }

          function setActiveChunkInTextView(i) {
            document.querySelectorAll(".chunk-span").forEach(el => el.classList.remove("active"));
            const el = document.querySelector(`.chunk-span[data-idx="${i}"]`);
            if (el) {
              el.classList.add("active");
              el.scrollIntoView({ behavior: "smooth", block: "center" });
            }
          }

function hideTextView() {
  const textView = document.getElementById("textView");
  textView.style.display = "none";
  textView.innerHTML = "";
  document.body.classList.remove("reader-active");
}

document.getElementById("readerToggleBtn").addEventListener("click", async () => {
  if (!pdfDoc) return;
  stopAudio();
  document.getElementById("chunkTimeline").innerHTML = "";
  if (!readerMode) {
    readerMode = true;
    await showTextView(currentPage);
  } else {
    readerMode = false;
    hideTextView();
    await renderPage(currentPage);
  }
});

document.getElementById("zoomInTextBtn").addEventListener("click", () => {
  readerFontPx = Math.min(readerFontPx + 2, 36);
  document.getElementById("textView").style.setProperty('--readerFont', readerFontPx + "px");
});

document.getElementById("zoomOutTextBtn").addEventListener("click", () => {
  readerFontPx = Math.max(readerFontPx - 2, 12);
  document.getElementById("textView").style.setProperty('--readerFont', readerFontPx + "px");
});

}); // end DOMContentLoaded
</script>
</body>
</html>

